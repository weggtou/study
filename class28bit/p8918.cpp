/*推论
每一秒都只能跳2^(n-1)距离
说明可以储存为二进制数，第i位就是第i+1秒是否向前跳
由于不向前跳就只能向后跳，所以，还要减一个数
比如
11011就要减00100，因为在第三秒没有往前跳就只能向后跳，要减掉
由此可见，一个奇数肯定会减去偶数，偶数肯定会减去奇数，所以能到达的地方一定
是奇数

11011-00100 = 10111
10011-01100 = 00111
110011-001100 = 100111；
最后的距离将0的位置往后移动一位，最前位补1就是被减数
10101-01010 = 01011 两个0也是一样的
所以所有的奇数都可以到达；

如何判断最少跳几秒呢；
由于是将距离中有0的位置往后移动一位最前面补0，所以最后的秒数肯定是最高位1的位置
如果中间没有0那么每秒都向前跳肯定是最优解，
所以只需要找最高位的1的位置就行
*/
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  if(n&1){
    cout << 32-__builtin_clz(n) << endl;//built为前导0的个数
    //也可以
    int cont = 0;
    while(n){
      n>>=1;
      cont++;
    }//一直右移直到为0为止
    
  }else{
    cout << "no";
  }
}