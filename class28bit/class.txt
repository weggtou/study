一.位运算
针对二进制数每位运算
1.与运算
两个操作数该位都是1结果才是1
2.或运算
两个操作数有一个是1结果就是1
3.异或运算
两个操作数相同结果是0，不同结果是1
4.取反运算
取反运算类似逻辑非，是1结果就是0，是0结果就是1
5.<<左移
将二进制数整体左移，末尾的位置补0
6.>>右移
整体右移，负数补1，正数补0

7.每个位运算对应位运算符
6&10 与
6|10 或
6^10 异或
~10 取反

8.位运算定理
(1)自己异或自己 -> 0
自己异或0 -> x
推论
一个数异或自己偶数次是自己，奇数次是0

(2)不用中间变量来交换两个整数
x = x^y;//相同的位置变为0，不同的位置变为1，结果为两数不同的位置都是1
y = x^y;//相同的位置变回1,不同的位置属于y的变为0，属于x的留下,最后y变为x
x = x^y;//同理，x变为y

(3)左移代表乘2(前提是第一个1不要出范围)
正数右移代表整除2，如果有0.5就直接舍弃
负数右移代表整除2，如果有0.5直接进一位

(4)fstream中的输入输出模式其实就是一个一字节的数
app = 0000001
ate = 0000010
bin = 0000100
in  = 0001000
out = 0010000
trunc = 0100000
noreplace 10000000
所以可以用一个数来代替两个方式的合并
如int mode = 0001001 = app|in
可以通过与运算检测是否有一个模式
return mode & ios::app
只要没有就会返回0

(5)异或符合交换律

(6)判断一个数的奇偶可以直接用x&1如果结果是1则为奇数，结果是0则为偶数

(7)若x^y = 1那么xy为相邻的两个数
二.二进制负数
如果二进制数有5bit，每位都是1，那么每位分别代表
16 8 4 2 1
4=2+2，8=4+4，16=8+8
但是由于第一位是1
4的前两位之和是3，8的前所有位之和是7
16的前所有位之和是15

所以如果该数是有符号整数
那么最高位是负数也就是-16
那么11111就是-16+15=-1，这个推理适用于所有位数的有符号整数
当第一位变为0时相当于减1，-16+14=-2
所以当有符号整数的最高位为1时，就是负数，
这是应该看的是0的位置，例如11010；
可以当作00101来算出值，为5，那么11010就是-6
因为-1-5=-6

三.扩展
类似fstream对种类的管理
如果想知道一个集合中一个种类的有无可以用类似的方法
但是，int类型最大只有64位，如果想管理更多的种类
c++提供了bitset
#include <bitset>

(1)bitset<8000> bs;
8000bit 1000字节

(2)bitset<8> bsi(123);可以直接使用整数初始化
bitset <8> bsb(0b1111011)用二进制数初始化
bitset <8> bss("10111000")用字符串初始化

(3)可以用下标访问对应的位，bss[0],输出的是bool
.count()数1的个数
.test(7)测试某一位是否为1
.set(0)将某一位设置为1
.reset(7)将某一位设置为0
.flip(2)将某一位取反
.to_ulong()转为usigned long
.to_ullong()转为usigned longlong
.to_string()转为字符串
其他看截图

