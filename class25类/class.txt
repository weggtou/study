类

1.结构体和类是相同的东西，只是默认的访问不同，结构体是默认公开，类是默认私密

2.访问控制，在类定义或结构体定义中在不想被外部访问的数据前加privat:会使该缩进下定义的东西
无法在外部访问，只能在内部访问。public：则是外部可以访问，protected代表子类可访问；
frind代表友元

3.类的定义：关键字为class其他的和结构体相同

4.虽然类默认private但是可以构造public来初始化，因为构造的函数相当于在类内，
而且还是公开的

5.如何构建类的初始化函数
class B{
    int* digits= nullptr;
    int size = 0;
    int sign = 0;
  public:
    B(string &str,int _sign){
        size = str.size();
        sign = _sign;
        digits = new int[size];
    }
}
这样就可以用B("11111",1)构造函数来初始化函数

6.构造函数可以有多个，看你自己建几个
如果
B(long long x){

}
就可以用B b(1000);来构造函数
同时当构造函数内只有一个参数时，可以直接用等于号赋值
B b =1000
多个参数用等于号赋值需要将变量写在大括号中
B c ={"789",1}

7.当定义了一个类的构造函数后，就不能直接类加变量名构造对象了
B d;
所以可以写一个无参数的构造函数
也可以在只有一个变量的构造函数里加默认值

8.class默认给一个构造函数
B e(a);
用同类型的函数构造函数

9.在构造函数中使用指针如果不释放指针会造成野指针出现，所以析构函数解决了
这一点,析构函数会在创造出来的变量被销毁时自动调用，专门为了销毁指针存在，
所以析构函数内要写删除之前申请的内存的函数

~B(){
    if (digits == nullptr) return;
    delete[] digits;
    digits = nullptr;

}

10.默认构造函数，及用相同类型的变量定义新变量时，会将就变量所有的值对应过去
所以如果参数里有指针的话也会对应过去，如果旧变量的指针被删除了，那
新变量的指针也会一起消除
所以要重新写默认构造函数
在函数内申请新的指针；

12.构造函数都不需要返回值

11.成员函数，就是构建类能使用的方法，也需要建在public里，
构建方法与构建函数相同，需要有返回值，因为是方法，所以默认有一个参数
比如累加，那函数只需要传递一个参数，默认传递自己。

B add(B &x){
    B r;
    int maxlen = max(size,x.size);
    ret.digits = new int[maxlen+1];
    return r;
}
B z = x.add(y)；
这里的ret和z享受相同的生命周期

12.对变量自身改变的成员函数不需要返回值，为void
但是也可以将自身返回，这样就可以多次调用
B& self_add(B &x){}
x.self_add(y).self_add(y);
因为有返回值，所以可以直接再使用方法，如果返回值为void，就不会了
因为c++再使用方法时会默认传递自己的指针为this，所以如果想返回自己，直接返回*this即可

13.运算符重载，可以将成员函数改成对应的操作符,将变量名改成operator加要定义的操作符即可
B operator +(B &x){}
注：在定义自增自减时，默认为前置，如果要定义后置需要在变量中加上哑元参数
例如
B operator++(int){}
为后置自加

14.重载括号可以构造仿函数，及看着和函数很像的操作

15.重载类型转换运算符
operator int(){
    int ret=0;
    return ret;
}
不需要定义返回类型，但是必须返回和重载类型转化相同类型的值
定义之后默认可以隐式转化，如定义了int类型的转化则该类型可以
直接当作下标使用
如果不想让系统自动判断隐式转化，怕出bug，可以在重载前加explicit
explicit operator int(){}
这样就只能手动转化了

16.如果想让外部定义的函数访问自定义类的内部参数，可以在定义类时
在public中写下friend 之后跟上外部函数的声名，包括返回类型，函数名，形参
例如
friend B operator+ (int,B&);
不仅可以将函数作为朋友，还可以将类作为朋友
friend class B;
也可以限制的更为仔细
friend int* B::digits;
这样就只能访问B的digit了

17.在类中只声名一下函数，可以在外面编写，只需要在编写函数时加上声名
class B{
    int* digits;
    int size;
  public:
    B(int);
    Bigint& operator=(B&);
};

B::B(int i){

}
Bigint& Bigint::operator=(Bigint &rhs){}
