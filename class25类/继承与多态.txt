继承
子类可以继承父类成员变量和函数，方便复用
子类可以访问父类的非私有成员，及可以访问到protected
但是子类创建的对象依然只能访问public

继承方式：
任何继承方式都不影响该子类对父类的访问但是会决定父类中的数据在子类中以
什么形式存在
1.class zi:public fu{}
父类中所有的成员类别都不变
2.class zi:protected fu{}
父类中protected成员不变但是public成员变成protected
3.class zi:private fu{}(不写默认为private)
父类中所有成员变为private

final：
如果建造类时class a final{}
则该类不能被继承

构造函数和析构函数的继承：
子类在调用构造函数时默认会隐式的调用父类的默认构造函数
但是如果父类的构造函数进行过函数重载则无法调用
就必须把调用父类的构造函数写出来
如果父类有多个构造函数可以在子类中使用using 继承名::父类构造函数名
来直接继承父类的构造函数

析构函数不能被继承，但是在子类析构函数调用后父类析构函数会自动调用

如果子类是public继承，则子类的对象可以直接转化为父类的类型，和父类存在一个容器中
vector <*fu> fu;
fu.push_back(new zi1());
fu.push_back(new zi2());

多态：
函数重载是静态多态
动态多态：
虚函数
在父类中定义函数前加上virtual
在子函数中重写时在函数名和小括号后加上override就可以重写函数

在使用delete销毁指针时只会调用基类的析构函数，所以基类的析构函数最好都写成
虚函数，子类的析构函数都写成override

纯虚函数；
在父类中没有实现的虚函数
virtual void x() = 0;
子类必须重写该函数
同时不能创建父类的对象，只能创建子类的对象

