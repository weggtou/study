sort
1.程序的复杂度用O()来表示
2.stl中的函数普遍用的是复杂度最低的方法
3.vector只能用a.begin()和a.end(),或a.begin()和a.begin()+n
4.原生数组只能使用a和a加n，因为原生数组名在函数中会自动变为第一个元素的指针，但是不是类，
没有成员函数所以不能使用begin()和end()
5.如果不想写begin()和end(),可以在sort前加上ranges::，这样括号内的begin和end可以直接简写成数组名，
之后的所用stl都是同理

nth_element(begint,nth_place,end)
1.作用是将第n小的数放到第n位，比先用sort排序在找第n个位置的数要快
2.第二个参数是a.begin()+n,要第几小的数n就是几
3.输出时第n小的数排在第n位置，所以要写a[n]
4.可以和sort一样有自定义排序方法

lower_bound(begin,end,v,fx)upper_bound(begin,end,v,fx)
1.lower的作用是在一个有序的数组中找到第一个>=v的迭代器
2.upper的作用是在一个有序的数组中找到第一个>v的迭代器
3.如何算有序呢，例如从小到大排列
4.复杂度是O(logn)

next_permutation(begin,end)prev_permutation(begin,end)
1.next是直接将数组改为下一个比数组现在大的排列，如果为最大排列，在下一次调用函数时会将函数改为最小的排列后返回false
2.prev与next相似但是是将数组改为比现在小的排列，如果为最小则改为最大排列后返回false

unique(begin,end,fx)
1.直接改变原函数，将相邻的一样的元素删除，并返回最后位置的迭代器
2.为什么返回最后位置的迭代器呢，因为他在删除完后后面还会跟一些莫名奇妙的东西，
所以要配合vec.erase(unique(begin,end,fx),end())使用
3.由于只是删除相邻的相同元素，所以可以在使用前先排序，sort，这样就可以删掉所有一样的元素，每个只留一个
4.fx可以定义相同的标准

minmax_element(begin,end,fx)
1.返回由两个指针组成的新类，所以可以用auto[a,b] = minmax_element将两个指针拿出来，a为最小值，b为最大值
2.并没有变得简单
3.返回的是指针记得解应用

min_element(begin,end,fx)max_element(begin,end,fx)
1.返回最大值指针，最小值指针
2.并没有变得简单

accumulate(begin,end,开始值,fx)
1.累加函数，默认返回将所有值累加到开始值上
2.返回值与开始值类型相同
3.0ll中的0为longlong类型
4.fx可以定义累加方法，如变成累乘或累减等
5.并没有变得简单

vector的方法
1.push_back,pop_back复杂度是1
2.insert,erase复杂度是n，所以尽量不要使用
3.数组开大小之后push_back比数组没有开大小push_back快，
所以当没有确定数组多大时可以用a.reserve(n)来提前预留位置push_back，快一点
4.用new开连续内存是最快的但是不方便操作

queue stack deque
include <queue>
他们都是类似于vector的数据类型
1.queue
支持push，pop，empty，size，front
push默认在最后插入
pop默认在最前删除
具有比vector快的插入和删除速度，但是不支持下标访问
开queue的方法
queue<int> a
front
int x = a.front()
(vector也有)

2.stack
插入和删除都是在尾部，不支持下标，性能与vector类似

3.deque
支持push_back,pop_back,push_front,pop_front，也支持下标访问
但是下标访问性能远低于vector

4.模板
所有类型后面跟着的<>都是模板，它可以定义类型的状态，不只有一个参数

5.greater <int>
greater <int> 是一个类，但是它默认重载了()，所以是一个仿函数

6.priority_queue<>
优先队列
(1)优先队列只能用top来获取第一个值
(2)priority_queue会将存入的可比较数据自动按从大到小排列
(3)push默认从后加入，pop默认从前删除
(4)我们称这种从头部输出特征值的元素组合称为堆，从大到小排列叫大顶堆
从小到大排列叫小顶堆
(5)将大顶堆变成小顶堆的方法:更改模板
priority_queue <存放类型，基于什么类型，比较器(函数的类型)>
以int为例
priority_queue<int,vector<int>,greater<int>>
由于greater<int>是类型，且是拟函数，所以可以作为比较器
函数指针，函数名，匿函数都无法作为比较器
如果要用lambda，需要用decltype获取匿名函数类型
应为他会在优先队列调用时用给的比较器创建一个无参数的对象用来传递值，而函数名不是类型，不能用来构建对象

虽然函数指针在不解应用的情况下可以当函数指针类型无参数时为空指针，必须指向函数时才能使用

为什么decltype匿名函数可以用呢：因为匿名函数的类型是匿名函数类，可以用来构建对象，并且重载了()，可以当函数调用
但是decltype函数得到的是函数的类型，不能用来构建对象，更不用说传递参数了。

set multiset unordered_set
都不支持下标访问
1.set 有序 唯一
默认从小到大排序，并且唯一
insert,find,erase,count复杂度logn
(1)可以使用find，返回迭代器，如果没有返回.end
(2)可以使用insert，erase，count，如果insert不写位置，默认为最后
(3)也可以使用lower_bound

2.multiset 有序，不唯一
find复杂度为n，其他都为logn
(1)可以insert,erase，count，find
(2)erase有特殊性，如果直接erase(1)会将所有1删掉,并返回删除的
元素个数
(3)为了只删除一个元素，需要删除指定元素的迭代器。erase(a.find(1))
这时erase返回的是被删除元素的下一个迭代器
(4)如果find的元素不存在会返回end，而erase(end)会报错，所以在删除
时一定要先判断元素存不存在
(5)但如果是确定元素的删除,erase(1)如果这个元素不存在就不会出现问题
(6)额外函数，lower_bound(n)，返回第一个大于等于n的元素的位置，如果
没有则返回end
(7)只有支持比较大小的类型才可以使用，或者在模板中的第二个位置写比较函
数的类型

3.unordered_set 无序 唯一
inset,erase,find,count复杂度都为1*c
(1)元素要支持可哈希，或者在模板中的第二个参数自定义哈希值的计算方法，
哈希值为无符号整数，所以自定义函数返回的值要为size_t类型
(2)unordered_set判断两个数是否相同看他们哈希值是否相同，再看他们的实际值
是否相同，分别对应模板中的第二和第三个参数
unordered_set <pair<int,int>,decltype([](int x){
    return (size_t)x.first;
}),decltype([](int a,int b){
    return a.first==b.first;
})>
示例中第二个参数定义了pair的哈希值为第一个int的值，第三个参数定义了
两个pair相等的条件是first相同，所以当输入的值第一个int相同时unordered
就会认为他们相同
那么如何使用呢，对于有些小数的相加可能会有些误差，所以可以自定义他们相同
的判断方法来将误差忽略
unordered_set <double,decltype([](double a){
    return (size_t) a*1e6;
}),decltype([]{
    return abs(a-b)< 1e-6;
})>
这样当两个小数误差在小数点后六位之后，即可相等

4.性能（set普遍优于multiset）
inset vector最快，其次unordered_set，最后set
find unordered_set要快于set快于vector


map(就是字典)
map相当于将set作为标签后面跟了一个元素
1.map
insert,erase,find,[]
(1)map<string,int> 对应set <string>
但是按顺序排列的只有第一个值，第二个值没有要求，与第一个值绑定
可以通过第一个值访问第二个值
(2)insert时要按pair来添加元素

2.multiset,unordered_map同理
(1)在访问没有的键时，会创建一个键，在给这个键赋值为第二个值的默认构造
例如没有unknown
但是访问了
cout << a[unknown]
会输出0
因为新建了一个键并赋值为int的默认构造
如果此时cout << a.size()会比之前大一个，因为自动新建了
