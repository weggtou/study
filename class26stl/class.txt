sort
1.程序的复杂度用O()来表示
2.stl中的函数普遍用的是复杂度最低的方法
3.vector只能用a.begin()和a.end(),或a.begin()和a.begin()+n
4.原生数组只能使用a和a加n，因为原生数组名在函数中会自动变为第一个元素的指针，但是不是类，
没有成员函数所以不能使用begin()和end()
5.如果不想写begin()和end(),可以在sort前加上ranges::，这样括号内的begin和end可以直接简写成数组名，
之后的所用stl都是同理

nth_element(begint,nth_place,end)
1.作用是将第n小的数放到第n位，比先用sort排序在找第n个位置的数要快
2.第二个参数是a.begin()+n,要第几小的数n就是几
3.输出时第n小的数排在第n位置，所以要写a[n]
4.可以和sort一样有自定义排序方法

lower_bound(begin,end,v,fx)upper_bound(begin,end,v,fx)
1.lower的作用是在一个有序的数组中找到第一个>=v的迭代器
2.upper的作用是在一个有序的数组中找到第一个>v的迭代器
3.如何算有序呢，例如从小到大排列
4.复杂度是O(logn)

next_permutation(begin,end)prev_permutation(begin,end)
1.next是直接将数组改为下一个比数组现在大的排列，如果为最大排列，在下一次调用函数时会将函数改为最小的排列后返回false
2.prev与next相似但是是将数组改为比现在小的排列，如果为最小则改为最大排列后返回false

unique(begin,end,fx)
1.直接改变原函数，将相邻的一样的元素删除，并返回最后位置的迭代器
2.为什么返回最后位置的迭代器呢，因为他在删除完后后面还会跟一些莫名奇妙的东西，
所以要配合vec.erase(unique(begin,end,fx),end())使用
3.由于只是删除相邻的相同元素，所以可以在使用前先排序，sort，这样就可以删掉所有一样的元素，每个只留一个
4.fx可以定义相同的标准

minmax_element(begin,end,fx)
1.返回由两个指针组成的新类，所以可以用auto[a,b] = minmax_element将两个指针拿出来，a为最小值，b为最大值
2.并没有变得简单
3.返回的是指针记得解应用

min_element(begin,end,fx)max_element(begin,end,fx)
1.返回最大值指针，最小值指针
2.并没有变得简单

accumulate(begin,end,开始值,fx)
1.累加函数，默认返回将所有值累加到开始值上
2.返回值与开始值类型相同
3.0ll中的0为longlong类型
4.fx可以定义累加方法，如变成累乘或累减等
5.并没有变得简单

vector的方法
1.push_back,pop_back复杂度是1
2.insert,erase复杂度是n，所以尽量不要使用
3.数组开大小之后push_back比数组没有开大小push_back快，
所以当没有确定数组多大时可以用a.reserve(n)来提前预留位置push_back，快一点
4.用new开连续内存是最快的但是不方便操作

queue stack deque
他们都是类似于vector的数据类型
1.queue
支持push，pop，empty，size，front
push默认在最后插入
pop默认在最前删除
具有比vector快的插入和删除速度，但是不支持下标访问
开queue的方法
queue<int> a
front
int x = a.front()
(vector也有)

2.stack
插入和删除都是在尾部，不支持下标，性能与vector类似

3.deque
支持push_back,pop_back,push_front,pop_front，也支持下标访问
但是下标访问性能远低于vector