sort
1.程序的复杂度用O()来表示
2.stl中的函数普遍用的是复杂度最低的方法
3.vector只能用a.begin()和a.end(),或a.begin()和a.begin()+n
4.原生数组只能使用a和a加n，因为原生数组名在函数中会自动变为第一个元素的指针，但是不是类，
没有成员函数所以不能使用begin()和end()
5.如果不想写begin()和end(),可以在sort前加上ranges::，这样括号内的begin和end可以直接简写成数组名，
之后的所用stl都是同理

nth_element(begint,nth_place,end)
1.作用是将第n小的数放到第n位，比先用sort排序在找第n个位置的数要快
2.第二个参数是a.begin()+n,要第几小的数n就是几
3.输出时第n小的数排在第n位置，所以要写a[n]
4.可以和sort一样有自定义排序方法

lower_bound(begin,end,v,fx)upper_bound(begin,end,v,fx)
1.lower的作用是在一个有序的数组中找到第一个>=v的迭代器
2.upper的作用是在一个有序的数组中找到第一个>v的迭代器
3.如何算有序呢，例如从小到大排列
4.复杂度是O(logn)

next_permutation(begin,end)prev_permutation(begin,end)
1.next是直接将数组改为下一个比数组现在大的排列，如果为最大排列，在下一次调用函数时会将函数改为最小的排列后返回false
2.prev与next相似但是是将数组改为比现在小的排列，如果为最小则改为最大排列后返回false

unique(begin,end,fx)
1.直接改变原函数，将相邻的一样的元素删除，并返回最后位置的迭代器
2.为什么返回最后位置的迭代器呢，因为他在删除完后后面还会跟一些莫名奇妙的东西，
所以要配合vec.erase(unique(begin,end,fx),end())使用
3.由于只是删除相邻的相同元素，所以可以在使用前先排序，sort，这样就可以删掉所有一样的元素，每个只留一个
4.fx可以定义相同的标准

minmax_element(begin,end,fx)
1.返回由两个指针组成的新类，所以可以用auto[a,b] = minmax_element将两个指针拿出来，a为最小值，b为最大值
2.并没有变得简单
3.返回的是指针记得解应用

min_element(begin,end,fx)max_element(begin,end,fx)
1.返回最大值指针，最小值指针
2.并没有变得简单

accumulate(begin,end,开始值,fx)
1.累加函数，默认返回将所有值累加到开始值上
2.返回值与开始值类型相同
3.0ll中的0为longlong类型
4.fx可以定义累加方法，如变成累乘或累减等
5.并没有变得简单

vector的方法
1.push_back,pop_back复杂度是1
2.insert,erase复杂度是n，所以尽量不要使用
3.数组开大小之后push_back比数组没有开大小push_back快，
所以当没有确定数组多大时可以用a.reserve(n)来提前预留位置push_back，快一点
4.用new开连续内存是最快的但是不方便操作

queue stack deque
include <queue>
他们都是类似于vector的数据类型
1.queue
支持push，pop，empty，size，front
push默认在最后插入
pop默认在最前删除
具有比vector快的插入和删除速度，但是不支持下标访问
开queue的方法
queue<int> a
front
int x = a.front()
(vector也有)

2.stack
插入和删除都是在尾部，不支持下标，性能与vector类似

3.deque
支持push_back,pop_back,push_front,pop_front，也支持下标访问
但是下标访问性能远低于vector

4.模板
所有类型后面跟着的<>都是模板，它可以定义类型的状态，不只有一个参数

5.greater <int>
greater <int> 是一个类，但是它默认重载了()，所以是一个仿函数

6.priority_queue<>
优先队列
(1)优先队列只能用top来获取第一个值
(2)priority_queue会将存入的可比较数据自动按从大到小排列
(3)push默认从后加入，pop默认从前删除
(4)我们称这种从头部输出特征值的元素组合称为堆，从大到小排列叫大顶堆
从小到大排列叫小顶堆
(5)将大顶堆变成小顶堆的方法:更改模板
priority_queue <存放类型，基于什么类型，比较器(函数的类型)>
以int为例
priority_queue<int,vector<int>,greater<int>>
由于greater<int>是类型，且是拟函数，所以可以作为比较器
函数指针，函数名，匿函数都无法作为比较器
如果要用lambda，需要用decltype获取匿名函数类型
应为他会在优先队列调用时用给的比较器创建一个无参数的对象用来传递值，而函数名不是类型，不能用来构建对象

虽然函数指针在不解应用的情况下可以当函数指针类型无参数时为空指针，必须指向函数时才能使用

为什么decltype匿名函数可以用呢：因为匿名函数的类型是匿名函数类，可以用来构建对象，并且重载了()，可以当函数调用
但是decltype函数得到的是函数的类型，不能用来构建对象，更不用说传递参数了。

