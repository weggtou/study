1.c语言中运算中的变量是什么类型结果就是什么类型
例如
int i=1
1/i就是整形

2.在遍历矩阵时可以用
int l[m][n];
for (auto &line: l){
    for (auto &a:line)
}
及先将第一行绑定到line，此时line为每一行组成的数组
因为 x = l[1]时x为l第一行组成的数组，虽然无法直接输出，但可以遍历
在嵌套的循环中用a绑定line中的各各元素

3.四舍五入用round

4.for (auto &g :v1){
        cin >> g;
    }
    可以写成一行
for (auto &g:v1) cin >> g;

5.vector反转(include algorithm)
reverse(a.begin(),a.end()) 按位置
reverse(a,a+n) 按元素

6.如果是一个每次移动k的循环
不要for (int i = 0; a0+i*k <m ; i++)
直接for(int i = a0 ; i<m ; i+= k)
更简单

7.两个东西挨个交换可以将他们放到一个可变数组里
令index = 0;
每次使用后
index = 1-index;
这样每次使用a[index]
就会交换

8.判断最小值有专业的方法
bool found = false;用一个值来存储是否找到
int min_index = 0;用一个值来存储是否最小
for (遍历){
    if (a[i] < a[min_index] || !found){
        min_index = i
    }
}

9.希望数组的id和相同时可以在0号位置加一个用不到的数

10.在记录类似于开关灯或有没有被访问到的问题时可以新建一个数组来记录

11.对于可变数组和可变字串，没有设置初始值时是0，但是数组和字串是随机的
所以在定义数组或字串时要记得初始化

12.在reverse char类型时只能是元素型的反

13.字符串比较不支持直接用运算符
要用strcmp

14.在回行循环时例如凯撒加密一位
要让abc变为bcd统一向后移一位
但是在循环时到最后一位会出问题
所以
可以将索引变为(i+1)%len()
这样最后一个对应的正好是0依次类推

15.strcmp()第一个值输入的是起始位置

16.vector的种类可以是string

17.string 越界一定等于0

18.string 在用substr截时，如果索引范围大于长度，也不会有问题，
例如总共只有三个字符但是substr要截10个最后也会输出三个字符，不会有影响

19.在使用getline之前如果有正常输入及cin，则getline在第一次会读取上一次残留的回车
所以如果需要，则要提前进行一次getline把回车读取掉

20.#include <algorithm>reverse要申明

21.在输入的数量不确定时可以用
while(cin>>a)来输入

22.max能直接用了，不用那么麻烦

23.固定小数的输出位数
cout << fixed;
cout.precision(10);

24.多维数组统计p1464
#include <iostream>
#include <format>
using namespace std;

long long memo[21][21][21] = {0};

long long w(long long a, long long b, long long c) {
    if (a <= 0 || b <= 0 || c <= 0) return 1;
    if (a > 20 || b > 20 || c > 20) return w(20, 20, 20);
    if (memo[a][b][c] != 0) return memo[a][b][c];
    long long res;
    if (a < b && b < c) {
        res = w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);
    } else {
        res = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);
    }
    memo[a][b][c] = res;
    return res;
}

int main() {
    long long a, b, c;
    while (true) {
        cin >> a >> b >> c;
        if (a == -1 && b == -1 && c == -1) break;
        cout << format("w({}, {}, {}) = {}", a, b, c, w(a, b, c)) << endl;
    }
}

25.string 可以规定长度string(n,' ')规定为n个空格

26.#include <algorithm>
string 可以用count(a.begin(),a.end(),'a')来计数字符a在字符串a中的个数

27.在判断是否在括号内时，可以设定一个计数cont = 0，挨个遍历字符串
当a[i]=='('时加1，当a[i]==')'时减1，这时当cont=0时则在括号外面

28.遍历值是可以在循环中改变的

29.数组的size()函数是无符号longlong，在做减法时如果成为-1会转化为最大的无符号整数
所以在.size()做减法时，应该先转化为int

30.scanf 比cin快

31.int& x = y;和int* x = &y;
这里的两个&不同，左边是左值引用，相当于将y和x绑定在同一地址，是一辈子都绑定在一起，x就是y
对x的更改就是对y的更改，而右边&的意思是取地址，表示x是y的指针，但是x也可以更改为别的指针,可以把左边的情况
x是int&类型，为另一个int值的代号

32.reserve和直接默认大小的区别是reserve内没有内容，vector的大小放多少是多少，而直接定大小是
大小确定，提前塞入了默认值

33.迭代器也可以解引用

34..find()的支持情况
只有set和map系列支持

algorithm中的find支持情况
vector，deque支持，stack，queue，priority_queue都不支持

35.multiset和set的唯一区别就是一个唯一一个不唯一

36.最小值添加如果是唯一的用set，不唯一用priority_queue或mulitset，能用priority_queue
就用，性能更好

37.支持lower_bond的也支持upper_bond,返回第一个大于x的迭代器

38.priority_queue的比较函数是反的，如果想变成小顶堆要写大于在前的比较函数

39.随机访问迭代器(支持与数字加减)：vector，deque
双向迭代器(支持自加自减)：map，set，multimap，multiset,unordered只支持自加，vector,deque
不支持迭代器：queue，priority_queue,stack
支持用迭代器解指针的容器：vector，map，set，deque，multimap,multiset,unordered,vector,deque
是否可以通过迭代器更改:vector,deque可以用迭代器改值，map,multimap,set,multiset不能改键，set里全是
键所以改不了

40.注意自减在前和自减在后的区别，*(--a.end())是最后一个值，*(a.end()--)是容器最后一个值
之后的值，这就是先减再用和先用再减的区别

41.vector用lower_bond相当的快，find的速度是n，比较慢，所以能用lower_bond
就用lower_bond

42.场宽表示数据再最右边

43.只有有序的vector可以使用lower_bond函数，set只能使用lower_bond方法

44.cin,cout最好不要放在一个循环里，不断cincout交换会不断刷新缓冲区导致速度变慢，或者用scanf，和printf

45.1ull整数字面量，代表unsigned long long 类型的1

46.unsigned int 可以简写为unsigned

47.命名函数时在类型旁边加&说明返回被操作的数本身，例如函数重载了=，a=b返回的就是a本身那么该操作符就可以连等a=b=c

48.在main函数内不能重载操作符

49.int 10^9 long long 10^19

50.当判断x==1y==2或y==1x==2类似这种情况时，可以直接写成x+y==3

51.变量名不能左移右移

52.成员变量如果是引用，说明在构造函数时进行的变量的复制建立的变量与形参进行了绑定