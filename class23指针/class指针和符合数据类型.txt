1.复合数据类型：
数组，字符串，vecter string,函数

2.指针特性
指针可以进行加减运算，被称为地址偏移，但是加一不一定是
往后移动1bit，而是移动一个类型的长度，例如如果是int的指针
则移动4bit
此类运算可以写成
int* ptr =&x
cout << *(ptr+1)<<endl;
也可以写成
cout << ptr[1]<<endl;
这种形式可以直接进行运算后对指针进行取值

3.对于连续储存的类型就可以使用2的方法取值
int arr[5] = {1,2,3,4,5};
int* ptr = &(arr[0]);
for (int i =0;i<5;i++){
    cout << ptr[i] << ' ';
}
cout << endl;
将第一个值的位置赋值给指针，之后就可以挨个推出结果；
也可以把数组直接赋值给指针达到同样的效果
int* ptr =arr
应为发生了隐式转化，转化成了第一个元素的地址

4.数组的类型：类型[长度]
例如int类型的数组的类型是int[n]
所以数组的指针，而不是数组第一个值的指针应该这样写
int (*ptr) [n] = &arr

由于这个特性过于反人类
可以用using给类型取个别名
例如 
using Arr5 = int[5];
Arr5 arr = {1,2,3,4,5};
Arr5* ptr = &arr;
相当于
int arr [5] = {1,2,3,4,5};
int (*ptr)[5] = &arr; 

5.如果定义函数传递数组，传递的只有首元素的指针，会丢失长度
所以，在定义函数传递数组时需要在传一个长度元素
但如果传递的时整个数组的指针，则不需要传递大小
可以直接将解引用的结果当作数组使用

还可以使用auto& arr来直接传递数组，是c加加20的特性

6.二维数组
二维数组的本质是元素为数组的数组，在内存中也是一维连续的
所以当直接将数组赋值给指针指针类型需要是数组指针，应为为第一个元素的指针
第一个元素是一个数组
所以将第一个元素传递给指针，或将第一个元素的第一个元素传递给指针的结果是相同的
int* ptr = arr[0] 和int* ptr = arr[0][0]
第一个会默认变为第一个元素的指针，与第二个相同

7.字符串指针
若输出未定义的char指针，会直接报错而不是输出位置
因为输出char类型指针会直接将地址解引用，然后一直往后输出直到遇到0
所以char*想要获得表示的地址需要先转化为void*

所以如果将字符串赋值给指针可以直接将指针当字符串输出，而不用解引用
但是单个字符不行，单个字符不带\0

8.vecter string 对象类型容器
vecter<int>*
同理是什么类型写什么类型的指针
指针解引用后可以直接当原类型用

对于(*ptr).push_back;等
c加加20提供了简便写法
ptr->push_back

9.迭代器即.begin().end()
虽然不是指针但也支持++--和解引用

10.函数的指针
int add(int a,int b){

}
可以保存为指针
int (*ptr)(int,int) = add;

函数指针可以不通过解引用直接当做函数使用
add(a,b) == ptr(a,b)

函数指针相当于把函数保存为了一个变量，可以随时改变这个变量，调用这个变量
还可以作用参数传递给要用到函数的函数，而函数名不行，在没有指针之前只能用lambda来传递

