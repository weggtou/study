一.第一种分类
c加加将内存分为，代码区，全局区，堆区，栈区

1.代码区：
分为text和rodata
text中存储逻辑代码
rodata中存储字符串等字面量

2.全局区
分为data段和bss段
data段存储初始化的全局变量或者由static定义的静态变量
bss段储存未初始化的全局或静态变量

3.堆区
通过malloc或new等方法申请的动态内存，需要手动操作

4.栈区
函数内定义的除静态变量以外的变量

二.第二种分类
内存分为静态生命周期、动态生命周期、自动生命周期

1.静态生命周期：
代码区、全局区
程序启动时申请，程序结束时销毁
(1)全局变量：
全局都可以使用，所有种类的变量就算没有初始化也默认为0
(2)静态变量：
在函数内定义变量时前面加上static就可以在整个程序运行时都存在
例如
定义一个函数
void func(){
    static int conut;
    conut++;
    cout << conut << endl;
}
如果连续两次定义这个函数就会输出1，2
应为第一次运行为1后没有销毁，第二次运行再次访问就变成了2
但是与全局变量不同的是静态变量只能在该函数中访问

2.动态生命周期：
堆区
手动申请销毁
无限大小，如果超出内存限制甚至会将硬盘映射为内存
C语言通过<stdlib.h>中的malloc来申请内存
参数是内存大小，返回void*指针
void* malloc(size)

其他方法：
void* calloc(个数，大小)自动清空个数乘以大小的内存
void* realloc(要改变的指针，大小)重新分配内存大小

用free(指针名)进行释放

c++中用new申请内存
int* p1=new int;
申请时需要跟上类型
如果是多个
int* p2=new int[5]()
在括号中加入元素个数
圆括号是申请的内存内存储的值，如果什么也不写就都是0
也可以用{}代替()花括号内放初始值

delete 指针名 释放
如果申请的是多个则要在delete后面加括号

3.自动生命周期：
栈区
函数开始时申请函数结束时释放
变量在栈的底部开始依次向上分配，函数结束就销毁
递归起始就是入栈，递归挨个结束，内存依次销毁
但栈的大小比较小，当函数一直进行时会把栈占满导致栈溢出

三.内存泄漏
如果指针变量在函数内，在申请内存时会将申请到的内存的第一个的地址赋值给指针变量
但是当函数运行完，虽然指针作为自动生命周期变量销毁了，但是申请的内存还没有释放
所以这些内存会被一直站着，再申请内存时系统不会考虑他们，这个情况叫内存泄漏
所以在每次申请完内存后要进行释放

四.悬挂指针
和内存泄漏相反，悬挂指针是指针变量对应的地址还在，但是对应的内存被释放了，所以里面存着什么
就不确定了，在用指针变量访问的结果是未知的
所以在释放指针后最好将只针的值设置为nullptr
不仅是指针本身，只要是指向这个地址的指针都会成为悬挂指针

五.智能指针
<memory>

shared_ptr<指针类型> = maker_shared<类型>(大小);
这种类型的指针在指针被销毁时指向的内存会自动销毁
不会内存泄漏
如果复制了多份，则内存会存在到最后一个指针被销毁时销毁

unique_ptr<指针类型> = maker_shared<类型>(大小)；
不能被复制，指针销毁时内存自动释放

weak_ptr
只能赋值别的指针，不能自己等于
当被复制的指针被销毁时，也跟着销毁
