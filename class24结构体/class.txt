1.结构体：将多个类型整合为一个整体

2.定义
struct 新类型名字{
    包含的数据类型 变量名；
    第二个；
    第三个；
}；

3.可以当单个变量用，也可以当数组使用

4.匿名结构体
如果懒得给结构体取名，可以不写类型名，直接再最后赋值给变量就行；
struct {
    类型 变量名；
}赋值给的变量名；
由于没有名字，所以无法定义别的变量；
若想定义别的变量
可以用decltype函数，该函数可以倒推出函数的类型
所以想通过匿名函数赋值多个变量，可以
decltype (匿名函数赋值给的变量名) 新变量
decltype 函数相当于类型了

5.通过赋值给的变量名加.变量名可以将结构体内的变量单独领出来

6.结构体可以嵌套定义

7.初始化
struct Student{
    int score;
    string name;
};
Student a= {99,"小明"}位置对应成员顺序
Student a= {99}可以不全初始化，但是位置还是从前往后排的
Student a{99};
auto a = Student{99}
Student a{.name="小明"}c加加20特有的不按顺序定义
结构体也可以和string一样直接赋值
Student b = a;

8.结构体的大小
以宽度最大的成员大小构建一个矩阵内存
从前到后挨个存储成员
成员存储的位置只能是每行中自己本身大小的倍数的位置
例如int是4字节则它只能放在一行中的第0号位或第四号位
最终所占的行乘列就是结构体的实际大小
所以注定会有空的内存没有被利用
为了让内存被最大限度的利用
最好从大到小的顺序来定义成员变量
特殊的，结构体嵌套时，内部的结构体以最大的成员长度作为长度
元素组合类型以单个的元素长度作为长度

9.c结构化绑定
在创建了新类型时
可以用auto[成员变量1，成员变量2] = 变量名
来获取成员变量但是，必须是全部成员才能识别
可以将此方法运用到范围循环中
Student arr[10];
for(auto &[score,name] : arr){
    cin >> scoer >> neme;
}
如果只需要一个变量
可以在结构化绑定时将另一个变量写成下划线；

10.c加加定义结构体
pair<类型1，类型2> a;(注意a不是类型名而是变量名)
将两种数据结合位一个新结构体
因为成员变量没有命名，所以要通过
a.first a.second
来访问
支持初始化和结构化绑定
pair<int，string> a{99,"小明"}
auto &[f,s] = a

如果要用auto定义，则要用auto b = make_pair(80,"小赵")来定义

可以直接自动大小比较不用再写一个函数

但pair只能用于两个元素
如果有三个元素要用tuple 和pair一样
但是无法用.first.second来访问成员变量
要用get<0>(a);get<1>a;get<2>a
来访问

除了结构化绑定，这两个方法还多了一个绑定
tie(f,s) = a;但是a必须已经定义，及已经赋值

11.vector emplace_back
当一个vector的元素是pair构成的类型时，直接push_back元素就需要
vec.push_back(make_pair(99,"小明"))
或者vec.push_back({99,"小明"})
而vec.emplace_back(99,"小明")可以只写数据什么都不写，非常高效
