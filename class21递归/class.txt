1.递归及自己调用自己的函数，将复杂的问题拆分成可以直接处理的问题
例如
写一个阶乘的函数
int jiecheng(int n){
    if (n==1) return 1;
    else return jiecheng(n-1)*n;
}
如果输入的数大于1他会一直调用知道可以直接处理为止，及n-1等于1时

2.但递归有时也会让问题复杂化，例如波菲拿起数列
int bofei(int n){
    if (n<=2) return 1;
    else return bofei(n-1)+bofei(n-2);
}
如果输入的数是7
他会分开计算6和5的波菲拿起数，这过程中肯定会导致重复计算，5就重复计算了一次，所以
可以在计算过程中进行数据的储存
vector <int> saved(n,-1)
int fib(int n){
    if(n<=2) return 1;
    if (saved[n]==-1){
        saved [n] = fib(n-1) +fib(n-2);
    }
    return saved[n];
}
这样在计算时会将对应位置的斐波那契数存到对应位置
例如对于fib(7)
会先计算fib(6)
在计算fib(6)时会将fib(6)中计算过的所有数保存
再在计算fib(5)时就会自动调用了

3.在解决问题时，如果这个问题的每个步骤都是类似的处理方法，且有一个能直接给出结果的情况
则可以转化为递归写法
例如汉诺塔问题
见图片